import type { Key } from 'path-to-regexp';
import { pathToRegexp } from 'path-to-regexp';
import type { Matcher } from './matchers';

/**
 * Extract the parameters of the `path-to-regexp` pattern from the path.
 *
 * @param path - The link that was matched.
 * @param regexp - The regexp from `path-to-regexp` that will be used.
 * @param keys - The array with keys generated by `path-to-regexp`.
 *
 * @returns An object with the parameter names and its corresponding values
 * from the path.
 */
const extractParameters = (path: string, regexp: RegExp, keys: Key[]): Record<string, string> => {
	const matches = path.match(regexp);

	if (!matches) {
		return {};
	}

	return matches.slice(1).reduce((result: Record<string, string>, value, index) => {
		const paramName = keys[index].name;
		if (typeof paramName === 'string') {
			result[paramName] = value;
		}

		return result;
	}, {});
};

/**
 * The regular expression flag.
 */
const REGULAR_EXPRESSION = 'RegExp:';

/**
 * Parses a path and extracts the parameters from it
 *
 * @param matchers - An array of Matchers
 * @param path - The path
 *
 * @category Utility Functions
 *
 * @returns the extracted parameters
 */
export function parsePath(matchers: Matcher[], path: string) {
	const result = matchers
		.sort(({ priority: p1 }, { priority: p2 }) => p1 - p2)
		.map(({ name, priority, pattern }) => {
			const keys: Key[] = [];

			const regexp = pattern.startsWith(REGULAR_EXPRESSION)
				? new RegExp(pattern.replace(REGULAR_EXPRESSION, ''))
				: pathToRegexp(pattern, keys);
			return { name, priority, pattern, regexp, keys };
		})
		.find(({ regexp }) => regexp.test(path));

	if (!result) {
		return {};
	}

	if (result.pattern.startsWith(REGULAR_EXPRESSION)) {
		const match = result.regexp.exec(path);

		if (match?.groups) {
			return match.groups;
		}

		return {};
	}

	return extractParameters(path, result.regexp, result.keys);
}
